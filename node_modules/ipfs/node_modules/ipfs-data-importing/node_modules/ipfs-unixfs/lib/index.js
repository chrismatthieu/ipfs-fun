'use strict';

var fs = require('fs');
var path = require('path');
var protobuf = require('protocol-buffers');
var schema = fs.readFileSync(path.resolve(__dirname, '../protos/unixfs.proto'));
var pb = protobuf(schema);
// encode/decode
var unixfsData = pb.Data;
// const unixfsMetadata = pb.MetaData // encode/decode

var types = ['raw', 'directory', 'file', 'metadata', 'symlink'];

function Data(type, data) {
  var _this = this;

  if (!(this instanceof Data)) {
    return new Data(type, data);
  }
  if (types.indexOf(type) === -1) {
    throw new Error('Type: ' + type + ' is not valid');
  }

  this.type = type;
  this.data = data;
  this.blockSizes = [];

  this.addBlockSize = function (size) {
    _this.blockSizes.push(size);
  };

  this.removeBlockSize = function (index) {
    _this.blockSizes.splice(index, 1);
  };

  // data.length + blockSizes
  this.fileSize = function () {
    var sum = 0;
    _this.blockSizes.forEach(function (size) {
      sum += size;
    });
    if (data) {
      sum += data.length;
    }
    return sum;
  };

  // encode to protobuf
  this.marshal = function () {
    var type = void 0;

    switch (_this.type) {
      case 'raw':
        type = unixfsData.DataType.Raw;break;
      case 'directory':
        type = unixfsData.DataType.Directory;break;
      case 'file':
        type = unixfsData.DataType.File;break;
      case 'metadata':
        type = unixfsData.DataType.Metadata;break;
      case 'symlink':
        type = unixfsData.DataType.Symlink;break;
      default:
        throw new Error('Unkown type: "' + _this.type + '"');
    }
    var fileSize = _this.fileSize();

    if (fileSize === 0) {
      fileSize = undefined;
    }

    return unixfsData.encode({
      Type: type,
      Data: _this.data,
      filesize: fileSize,
      blocksizes: _this.blockSizes.length > 0 ? _this.blockSizes : undefined
    });
  };
}

// decode from protobuf https://github.com/ipfs/go-ipfs/blob/master/unixfs/format.go#L24
Data.unmarshal = function (marsheled) {
  var decoded = unixfsData.decode(marsheled);
  if (!decoded.Data) {
    decoded.Data = undefined;
  }
  var obj = new Data(types[decoded.Type], decoded.Data);
  obj.blockSizes = decoded.blocksizes;
  return obj;
};

exports = module.exports = Data;